# 设计模式 
- 策略模式

学习案例、学习内容：类图、用例类、设计图参见
- https://github.com/chentian114/100-dayaction/tree/master/designpattern-1/images

## 策略模式(Strategy)

练习案例：
### DuckGame
- 鸭子游戏案例：现有各种鸭子，为它们增加飞行和叫声的行为。
 * 策略模式：定义一个算法族，使它们可以相互替换，使得算法可独立于使用它的客户而变化。
 * OO原则：封装变化、多用组合，少用继承、针对接口编程，不针对实现编程。
 
### Stratagem
- 三个锦囊妙计案例：三个计策，分别在三种情况下使用。
 * 定义一组算法， 将每个算法都封装起来， 并且使它们之间可以互换。
 * 策略模式的优点：算法可以自由切换；扩展性良好；
 * 策略模式的缺点：策略类数量增多；所有的策略类都需要对外暴露；
 * 策略模式的使用场景：多个类只有在算法或行为上稍有不同的场景；算法需要自由切换的场景；需要屏蔽算法规则的场景。
 
### CalculatorDemo
- 策略枚举案例：实现输入两个数字与加减操作符获得计算结果。
 * 它是一个浓缩了的策略模式的枚举。
 * 策略枚举是一个非常优秀和方便的模式， 但是它受枚举类型的限制，
 * 每个枚举项都是public、 final、 static的， 扩展性受到了一定的约束，
 * 因此在系统开发中， 策略枚举一般担当不经常发生变化的角色。
 
### FlowRecharge 
- 流量冲值案例：流量冲值，根据客户选择的不同产品，选择相应的冲值渠道进行冲值。
 * 策略模式属于行为型模式。
 * 策略模式将可变的部分从程序口抽象分离成算法接口，基于该接口实现一系列算法。
 * 特点是最终的结果是固定的，执行过程和执行逻辑不一致。例如：出行方式、支付方式等。
 
### GoWay 
- 出行方式案例：根据不同的天气选择不同的出行方式：晴天选择骑行、阴天选择步行、雨天选择开小车
 * 策略模式将同一接口的不同算法实现封装在不同的类中，从而使他们可以相互替换，达到客户端不受算法变动的影响，降低耦合。
 * 1）首先要定义一系列算法或一族的算法进行封装。
 * 什么是一系列，一族？拥有同一种特性的事物就是一系列或者说一族。
 * 2）这一族的算法可互换代替。
 * 分析：
 * 1）策略模式只是对算法进行封装，把算法和行为分隔开。
 * 2）具体怎么使用由客户端决定，客户端必须先理解所有的算法之间的区别，并且决定使用哪种算法。
 * 3）这一定程度上增加了客户端使用难度，但相应的提高了系统的灵活性。
 * 4）当需要频繁增加esle if或者case的情况量，可以考虑使用策略模式减少它们之间的耦合度，提高扩展性。
 
### SoldierGame 
- 士兵射击游戏案例：士兵使用各种枪支射击
 * OO原则：对扩展开放，对修改关闭。方便新增射击方式



## 观察者模式(Observer)

练习案例：
### WeatherDemo
-   气象布告板案例(实现观察者模式)
-   WeatherData对象获取气象站数据,当数据有更新时,需要实时更新三个气象板的数据(当前情况、气象统计、天气预报）


### WeatherJDKDemo
-   气象布告板案例(使用JDK内置的观察者模式实现)
-   WeatherData对象获取气象站数据,当数据有更新时,需要实时更新三个气象板的数据(当前情况、气象统计、天气预报）
     

### MagazineDemo
 - 订阅杂志案例：订阅杂志，有Magazine对象，People对象
 - 将观察者与被观察者（主题）解耦，普通类只需简单实现一个接口或抽象类就可以转换成观察者类，
  而且不需要观察者不断向被观察者抓取数据，被观察者会主动将自己的改变通知给多个观察者。
  
 - 在观察者中分为两种push模型与pull模式。
 - push模型
 - 　push模型是指被观察者发生改变时，将状态改变的信息全部或部分发送给观察者。
 - pull模型
 - 　pull模型是指被观察者发生改变时，将被观察者对象发送观察者，观察者可以自己获取感兴趣的内容。
 
 - 观察者模式给程序员提供一个建立对象之间一对多关联关系的良好方法，并能够将信息生成层与响应层分离，给以后的修改留下很好的结构。
 
 
### PoliceDemo
 -  警察蹲点监察嫌犯案例
 -  观察者模式定义的是一对多的依赖关系，一个被观察者可以拥有多个观察者，并且通过接口对观察者与被观察者进行逻辑解耦，降低二者的直接耦合。
       
 
 ## 装饰者模式(Decorator)
 ### BeverageDemo
 -  咖啡店案例：有四种咖啡（综合咖啡、深焙咖啡、低咖啡因咖啡、浓缩咖啡），每种咖啡可以加不同的配料组合。
 -  配料包括（摩卡、奶泡、豆浆、牛奶），每加一种配料，咖啡的价格要加上相应配料的价钱。
  
 ### PancakeDemo
 -  煎饼摊案例：煎饼小摊卖两种煎饼手抓饼和肉夹膜，煎饼可以自由搭配不同的配料组合，每增加一样配料价钱加上该配料的价钱。
 -  配料有：黄瓜丝、火腿、肉松、煎蛋 
 
 ### HeroDemo
 - 英雄学习技能案例：英雄李白，随着等级提升能够学习新的技能，包括Q,W,E。
 
 ### MonkeyDemo
 - 孙大圣变化案例：孙大圣本体是只猴子，他可以变成不同的动物：鱼、鸟。他的每一种变化都给他带来一种附加的本领。他变成鱼儿时，就可以到水里游泳；他变成鸟儿时，就可以在天上飞行。
    * 装饰者模式又名包装模式。装饰者模式以对客户端透明的方式扩展对象的功能，是继承的一个替代方案。
    * 装饰者模式的优点：
    * 1）目的在于扩展对象的功能。装饰者模式提供比继承更好的灵活性。装饰是动态的，运行时可以修改的；继承是静态的，编译期便已确定好。
    *  2）通过使用不同的装饰类及对它们的排列组合，可以创造出许多不同行为的组合。
    * 装饰者模式的缺点：1）会产生更多的对象。2）调试时不易排查错误。
    *
    * 装饰模式有透明和半透明两种，这两种的区别就在于装饰角色的接口与抽象构件角色的接口是否完全一致。
    *   1）透明的装饰模式也就是理想的装饰模式，要求具体构件角色、装饰角色的接口与抽象构件角色的接口完全一致。
    *   2）装饰角色的接口比抽象构件角色的接口宽的话，装饰角色实际上已经成了一个适配器角色，称为“半透明”的装饰模式。
    *
    *  装饰者模式：增强功能、不改变接口。
    *  半透明装饰者模式：增强功能、改变接口。
    *  适配器模式：不增加功能、改变接口。
    
 ## 简单工厂方法
 ### SimplePizzaFactoryDemo
 - 简单披萨工厂案例：
   * 当需要披萨时，就叫披萨工厂创建一个。
   * SimplePizzaFactory是创建披萨的工厂，createPizza()一般为静态的。
   * Pizza是我们的产品，定义为抽象类，具有一些有用的实现，这些实现可以被覆盖。
   *
   * 把创建披萨的代码移到另一个对象中，由这个新对象专职创建披萨，我们可以称这个新对象为工厂。
   * 把实例化对象的工作全部移到SimplePizzaFactory中，这样可以被多个客户调用；当以后实现改变时，只需修改这个类即可。
  
 ## 工厂方法模式(FactoryMethod)
 ### FactoryMethodPizzaDemo
 - 工厂方法模式披萨工厂案例：
    * 每个区域类型创建一个PizzaStore（NYPizzaStore、ChicagoPizzaStore、CaliforniaPizzaStore），每个子类各自决定如何制作披萨。
    * 工厂方法用来处理对象的创建，并将这样的行为封装在子类中。这样，客户程序中关于超类的代码就和子类对象创建代码解耦了。
 ### ExportFileDemo
 - 导出报表文件案例：
    *  系统需要支持对数据库中的数据进行导出，
    *  1）并且支持多种导出格式，如：HTML、PDF等，
    *  2）每种格式导出的结构有所不同，如标准报表、财务报表等。
    *
    *  案例分析：
    *  如果使用简单工厂模式，则工厂类必定过于臃肿。因为简单工厂模式只有一个工厂类，它需要处理所有的创建的逻辑。
    *  假如以上需求暂时只支持3种导出格式以及2种导出结构，那工厂类则需要6个if else来创建6种不同的类型。
    *  如果日后需求不断增加，则后果不堪设想。
    *  这时候就需要工厂方法模式来处理以上需求。
    *  在工厂方法模式中，将所有的对象的具体创建的工作交给子类去做。
    *  工厂方法抽象类ExportFactory有两个子类：ExportHtmlFactory、ExportPDFFactory分别负责创建导出格式为Html和PDF的对象
    *
    *  总结：
    *  工厂方法模式的用意是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。
    *  工厂方法抽象类角色：是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现这个接口。
    *  简单工厂模式把核心放在一个具体类上。
    *  工厂方法模式退化后可以变得很像简单工厂模式。设想如果非常确定一个系统只需要一个具体工厂类，那么不妨把抽象工厂类合并到具体工厂类中去。
    *  如果系统需要加入一个新的导出类型，那么所需要的就是向系统中加入一个这个导出类以及所对应的工厂类。
    *
    *  一个应用系统是由多人开发的，导出的功能是你实现的，但是使用者是其他人。
    *  这时候你应该设计的足够灵活并尽可能降低两者之间的耦合度，
    *  当你修改或增加一个新的功能时，使用者不需要修改任何地方。
    *  假如你的设计不够灵活，可能一个小的需求变更，便使得你的代码结构发生改变，并导致使用者都要修改他们的代码。
 ### FactoryHumanDemo
 - 女娲造人案例:
    * 女娲使用乾坤鼎造出不同肤色的人。
    *
    * 案例分析：
    * 对造人过程进行分析，该过程涉及三个对象：女娲、乾坤鼎、三种不同肤色的人。
    * 女娲可以用客户来表示，乾坤鼎类似于一个工厂，负责制造生产产品（即人类），
    * 三种不同肤色的人，都是同一个接口下的不同实现类， 对于乾坤鼎来说都是它生产出的产品。
    *
    * 总结：
    * 优点：
    * 1）良好的封装性，代码结构清晰。一个对象创建是有条件约束的，如一个调用者需要一个具体的产品对象，只要知道这个产品的类名就可以了，不用知道创建对象的过程， 降低模块间的耦合。
    * 2）工厂方法模式的扩展性非常优秀。在增加产品类的情况下，只要适当地修改具体的工厂类或扩展一个工厂类，就可以完成“拥抱变化”。
    * 3）屏蔽产品类。调用者只需要关心产品的接口，只要接口保持不变，系统中的上层模块就不需要发生变化。因为产品类的实例化工作是由工厂类负责的，生成具体哪一个产品是由工厂类决定的。
    * 4）工厂方法模式是典型的解耦框架。高层模块值需要知道产品的抽象类，其他的实现类都不用关心。
    * 使用场景：
    * 1）工厂方法模式是new一个对象的替代品，所有需要生成对象的地方都可以使用,但需要慎重地考虑是否要增加一个工厂类进行管理增加代码的复杂度。
    * 2）需要灵活的、可扩展的框架时，可以考虑采用工厂方法模式。        
        
 ## 抽象工厂模式(AbstractFactory)
 ### AbstractPizzaIngredientDemo
 - 披萨原料工厂：
    * 披萨原料有：面团、酱料、奶酪等。
    * 不同地区风味的披萨原料是不同的，纽约风味的披萨使用的原料是：薄饼面团、加番茄酱、雷奇亚干酪奶酪等。
    * 芝加哥风味的披萨使用的原料是：厚饼面团、李子番茄酱、马苏里拉奶酪等
 
 ### ComputerEngineerDemo
 - 电脑工程师组装电脑案例：
    *  我们在组装电脑的时候，通常需要选择一系列的配件，比如CPU、主板等。
    *  在确定装机方案时，需要整体考虑各个配件之间的兼容性。
    *  比如：CPU和主板，Intel的CPU根本就插不到AMD的主板中。CPU对象和主板对象其实是有关系的，需要相互匹配的。
    *  案例分析：
    *  对于装机工程师，只需要知道CPU和主板的接口，而需要不知道具体实现。
    *
    * 总结：
    *  每一个模式都是针对一定问题的解决方案。
    *  抽象工厂模式与工厂方法模式的最大区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则需要面对多个产品等级结构。
    *  产品族，是指位于不同产品等级结构中，功能相关联的产品组成的家族。如AMD的主板、芯片组、CPU组成一个家族，Intel的主板、芯片组、CPU组成一个家族。
    *  而这两个家族都来自于三个产品等级：主板、芯片组、CPU。一个等级结构是由相同的结构的产品组成。
    *  抽象工厂模式的好处：一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象。
    *  抽象工厂的功能是为一系列相关对象或相互依赖的对象创建一个接口。
    *  由于抽象工厂定义的一系列对象通常是相关或相互依赖的，这些产品对象就构成了一个产品族，也就是抽象工厂定义了一个产品族。
    *
    * 优点：
    *  分离接口和实现；客户端使用抽象工厂来创建需要的对象，而客户端根本就不知道具体的实现是谁。
    *  使切换产品族变得容易；
    *  产品族内的约束为非公开状态。
    * 缺点：
    *  不太容易扩展新的产品；如果需要给整个产品族添加一个新的产品，那么就需要修改抽象工厂，这样就会导致修改所有的工厂实现类。
    
  ## 单例模式(Singleton)
  ### ClassicSingletonDemo
  - 经典的单例模式案例：
     * 在多线程环境下会出错
   
  ### StaticSingletonDemo
  - 急切的单例模式案例：
     *  在静态加载类时创建对象
     *  单例模式的优点：1）减少内存开支2）减少创建对象所需系统的性能开销3）避免资源的多重占用
     *  单例模式的缺点：1）扩展困难，只能直接对代码进行修改
     *  单例模式的使用场景：1）要求生成唯一序列号的环境2）整个项目中只需要一个共享访问点
     *  3）创建一个对象需要消耗的资源过多
  
 ### SynchronizedSingletonDemo
 - 同步的单例模式案例：
    * 直接在获取单例的方法上通过synchronized同步来获取单例，在大量调用的情况下，性能会越来越差。
 
 ### ThreadSingletonDemo
 - 双重加检查加锁的方式实现单例案例：
    * 通过使用双重检查与volatile与局部使用synchronized，在实现线程安全地创建单例情况下不会对性能有太大的影响。
    * 只有第一次创建单例的时间需要同步。
    * 被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。
    * 由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高。因此一般，没有特别需要，不要使用。
 
 ### EnumSingletonDemo
 - 使用枚举类型实现单例模式案例：
    * 使用枚举实现单例非常简单，只需要编写一个包含单个元素的枚举类型即可。
    * 使用枚举来实现单例控制会更加简洁，而且提供了序列化机制，并由JVM提供保障防止多次实例化。
      
## 命令模式(Command)
 ### OrderDemo
 - 点餐案例：
   * 客户点餐，填写订单，招待员拿到订单将其放到订单栏，并通知厨师制作餐点。
   
 ### RemoteControlDemo
 - 遥控器案例：
  * 一个遥控器有多个按钮，每对按钮控制一个电器的开和关，以及支持撤销操作。并希望能够提供扩展。
  
  ### AudioPlayerDemo
  - 盒式收音机案例：
     * 　用户有一个盒式录音机，此录音机有播音(Play)、倒带(Rewind)和停止(Stop)功能。
     * 案例分析：录音机的键盘便是请求者(Invoker)角色；客户是客户端角色，而录音机便是接收者角色。
     * Command类扮演抽象命令角色，而PlayCommand、StopCommand和RewindCommand便是具体命令类。
     * 用户不需要知道播音(play)、倒带(rewind)和停止(stop)功能是怎么具体执行的，这些命令执行的细节全都由键盘(Keypad)具体实施。
     * 用户只需要在键盘上按下相应的键便可以了。
     *
     * 所谓宏命令简单点说就是包含多个命令的命令，是一个命令的组合。
     *
     * 命令模式：把一个请求或者操作封装到一个对象中。命令模式允许系统使用不同的请求把客户参数化，对请求排队
     *  或者记录请求日志，可以提供命令的撤销功能。
     * 命令模式把请求的发送者和请求的执行分割开，委派给不同的对象。
     * 命令模式的优点：1）使得新的命令很容易加入到系统中2）能容易的设计一个命令队列3）可以容易实现撤销4）可以容易地将命令记入日志
     * 客户端：创建一个具体的命令。请求者：负责调用命令对象执行请求。接收者：负责具体实施和执行一个请求。
     * 命令模式优点：
     * 1）更松散的耦合，将发起命令的客户端与具体处理命令的接收者完全解耦，客户端完全不知道接收者是什么样子。
     * 2）更动态的控制，把请求封装起来，可以动态的对请求进行参数化、队列化和日志化等，使系统更灵活。
     * 3）复合命令，很容易的组合命令，即宏命令，使系统功能更强大。
     * 4）更好的扩展，很容易添加新的命令。
   
  ### GroupRequirementDemo
  - 项目组需求案例：
     * 客户会提不同的需求到项目组如：增加一个需求、修改一项需求、删除一个页面，项目组要对这些需求进行处理。
     * 项目组分为：需求组、美工组、研发组。增加一个需求需要需求组、美工组、研发组参与。删除一个页面需要需求组与研发组删除参与。
     *
     * 需求分析：
     * 将客户需求封装成命令，客户只需要关注其所提的需求即可，而不需要关注项目组具体处理该任务的项目组内部信息。
     * 项目组长接到用户需求，对客户需求进行参数化，如：增加一个需求就是一个新增需求的命令，
     * 删除一个页面的需求就是一个删除页面的命令。命令里持有处理该任务的组目组成员的引用，
     * 并有一个统一的execute()方法调用具体项目组成员处理该需求。
     *
     * 要点总结：
     * 命令模式：将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。
     *  Receive接收者角色，处理命令
     *  Command命令角色，需要执行的请求
     *  Invoker调用者角色，接收命令，并执行命令
     * 优点：
     *  1）类间解耦，调用者角色与接收者角色之间没有任何依赖关系。
     *  2）可扩展性，Command子类可以非常容易扩展，调用者Invoker和高层次的Client不产一严重的代码耦合。
     * 缺点：
     *  1）类数量随命令数量增长而增长。可能造成类数量过多。
     * 实践：
     *  在实际Receiver一般采用封闭的方式，减少Client对Receiver的依赖。如案例中的各Group组。
    
## 适配器模式(Adapter)
  ### AdapterDemo
  - 对象适配器模式实现案例：
     *  适配器模式把一个类的接口变换成客户端所期待的另一个接口，从而使原本因为接中不匹配而无法一起工作的两个类能够在一起工作。
     *  适配器模式的用意是要改变源的接口，以便于和目标接口相容。
     *  适配器模式根据实现不同可分为类适配器和对象适配器两种。
     *  类适配器与对象适配器对比：
     *      类适配器使用继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。
     *      对于类适配器，适配器继承自Adaptee，使得适配器不能和Adaptee的子类或者兄弟类一起工作，继承是静态的，程序运行过程中无法改变。
     *      对于对象适配器，一个适配器可以把源类和它的子类都适配到目标接口，因为组合是动态的，程序运行过程中可以修改。
     *      对于类适配器，可以重定义Adaptee的部分行为，通过子类覆盖父类的实现方法。而对象适配重定义Adaptee的行为比较困难，只能进行一些新增。
     *  建议尽量使用对象适配器的实现方式，多用组合，少用继承。
     *  适配器模式的优点：
     *      更好的复用性；系统需要使用现有的类，而此类的接口不符合系统的需要，可以通过适配器可以让这些功能得到复用。
     *      更好的扩展性；在实现适配器的功能的时候，可以对适配的接口进行扩展。
     *  适配器模式的缺点：
     *      过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如调用A接口，其实内部被适配成B的接口实现。
     
  ### DuckAdapterDemo
  - 鸭子适配器案例：
     * 情况紧急，你需要一只鸭子上台表演，但你只有一只火鸡，所以你将火鸡打扮成鸭子上台表演了。
     
 ### MonkDemo
  - 鲁智深出家当和尚案例：
     *  和尚需要吃斋、念经、打坐、撞钟、习武，但鲁智深出家后只习武，其它戒律确并不遵守，如何代码实现花和尚。
     * 缺省适配器：为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接中进行扩展。
     *  适用场景：在一些情况下，必须让一个具体类实现某一个接口，但是又用不到接口所规定的所有方法。
     *  缺省适配器很好的处理这一情况，设计一个抽象的适配器类实现接口，此抽象类给接口的所有方法提供一个空的方法。
     *  任何继承自抽象类的具体类都可以选择它所需要的方法进行实现，而不需要理会其它方法。
     *  缺省适配器的用意是为了方便建立一个不平庸的类而提供的一种平庸实现。
     
  ### UserInfoDemo
   - 公司员工信息案例：
      *  人公司员信息系统管理所有员工的所有信息：用户姓名、家庭地址、办公电话、职位等。
      *  现在系统升级要能够管理公司借用的劳务公司人员信息，劳动服务公司是把人员信息分为：基本信息、办公信息和个人家庭信息。
      * 适配器模式优点：
      *     1）适配器模式可以让两个没有任何关系的类在一起运行。
      *     2）增加了类的透明性，访问的是Target目标角色，实际具体实现委托给了Adaptee源角色，而这些对高层模块调用者是透明的。
      *     3）提高了类的复用度，源角色在原有系统可以正常使用，在目标角色中也可以使用。
      *     4）灵活性好，当不需要这个适配器时，删除这个适配器即可。
      *  使用场景：
      *      修改一个已经投产中的接口时，适配器模式可能是最适合你的模式。比如系统扩展了，需要使用一个已有或新建立的类，但这个类又不符合系统的接口。
      *  注意事项：
      *      适配器模式最好在详细设计阶段不要考虑它，它不是为了解决还处在开发阶段的问题,而是解决正在服役的项目问题。
      
   