# 设计模式 
- 策略模式

学习案例、学习内容：类图、用例类、设计图参见
- https://github.com/chentian114/100-dayaction/tree/master/designpattern-1/images

## 策略模式(Strategy)

练习案例：
### DuckGame
- 鸭子游戏案例：现有各种鸭子，为它们增加飞行和叫声的行为。
 * 策略模式：定义一个算法族，使它们可以相互替换，使得算法可独立于使用它的客户而变化。
 * OO原则：封装变化、多用组合，少用继承、针对接口编程，不针对实现编程。
 
### Stratagem
- 三个锦囊妙计案例：三个计策，分别在三种情况下使用。
 * 定义一组算法， 将每个算法都封装起来， 并且使它们之间可以互换。
 * 策略模式的优点：算法可以自由切换；扩展性良好；
 * 策略模式的缺点：策略类数量增多；所有的策略类都需要对外暴露；
 * 策略模式的使用场景：多个类只有在算法或行为上稍有不同的场景；算法需要自由切换的场景；需要屏蔽算法规则的场景。
 
### CalculatorDemo
- 策略枚举案例：实现输入两个数字与加减操作符获得计算结果。
 * 它是一个浓缩了的策略模式的枚举。
 * 策略枚举是一个非常优秀和方便的模式， 但是它受枚举类型的限制，
 * 每个枚举项都是public、 final、 static的， 扩展性受到了一定的约束，
 * 因此在系统开发中， 策略枚举一般担当不经常发生变化的角色。
 
### FlowRecharge 
- 流量冲值案例：流量冲值，根据客户选择的不同产品，选择相应的冲值渠道进行冲值。
 * 策略模式属于行为型模式。
 * 策略模式将可变的部分从程序口抽象分离成算法接口，基于该接口实现一系列算法。
 * 特点是最终的结果是固定的，执行过程和执行逻辑不一致。例如：出行方式、支付方式等。
 
### GoWay 
- 出行方式案例：根据不同的天气选择不同的出行方式：晴天选择骑行、阴天选择步行、雨天选择开小车
 * 策略模式将同一接口的不同算法实现封装在不同的类中，从而使他们可以相互替换，达到客户端不受算法变动的影响，降低耦合。
 * 1）首先要定义一系列算法或一族的算法进行封装。
 * 什么是一系列，一族？拥有同一种特性的事物就是一系列或者说一族。
 * 2）这一族的算法可互换代替。
 * 分析：
 * 1）策略模式只是对算法进行封装，把算法和行为分隔开。
 * 2）具体怎么使用由客户端决定，客户端必须先理解所有的算法之间的区别，并且决定使用哪种算法。
 * 3）这一定程度上增加了客户端使用难度，但相应的提高了系统的灵活性。
 * 4）当需要频繁增加esle if或者case的情况量，可以考虑使用策略模式减少它们之间的耦合度，提高扩展性。
 
### SoldierGame 
- 士兵射击游戏案例：士兵使用各种枪支射击
 * OO原则：对扩展开放，对修改关闭。方便新增射击方式



## 观察者模式(Observer)

练习案例：
### WeatherDemo
-   气象布告板案例(实现观察者模式)
-   WeatherData对象获取气象站数据,当数据有更新时,需要实时更新三个气象板的数据(当前情况、气象统计、天气预报）


### WeatherJDKDemo
-   气象布告板案例(使用JDK内置的观察者模式实现)
-   WeatherData对象获取气象站数据,当数据有更新时,需要实时更新三个气象板的数据(当前情况、气象统计、天气预报）
     

### MagazineDemo
 - 订阅杂志案例：订阅杂志，有Magazine对象，People对象
 - 将观察者与被观察者（主题）解耦，普通类只需简单实现一个接口或抽象类就可以转换成观察者类，
  而且不需要观察者不断向被观察者抓取数据，被观察者会主动将自己的改变通知给多个观察者。
  
 - 在观察者中分为两种push模型与pull模式。
 - push模型
 - 　push模型是指被观察者发生改变时，将状态改变的信息全部或部分发送给观察者。
 - pull模型
 - 　pull模型是指被观察者发生改变时，将被观察者对象发送观察者，观察者可以自己获取感兴趣的内容。
 
 - 观察者模式给程序员提供一个建立对象之间一对多关联关系的良好方法，并能够将信息生成层与响应层分离，给以后的修改留下很好的结构。
 
 
### PoliceDemo
 -  警察蹲点监察嫌犯案例
 -  观察者模式定义的是一对多的依赖关系，一个被观察者可以拥有多个观察者，并且通过接口对观察者与被观察者进行逻辑解耦，降低二者的直接耦合。
       
 
 ## 装饰者模式(Decorator)
 ### BeverageDemo
 -  咖啡店案例：有四种咖啡（综合咖啡、深焙咖啡、低咖啡因咖啡、浓缩咖啡），每种咖啡可以加不同的配料组合。
 -  配料包括（摩卡、奶泡、豆浆、牛奶），每加一种配料，咖啡的价格要加上相应配料的价钱。
  
 ### PancakeDemo
 -  煎饼摊案例：煎饼小摊卖两种煎饼手抓饼和肉夹膜，煎饼可以自由搭配不同的配料组合，每增加一样配料价钱加上该配料的价钱。
 -  配料有：黄瓜丝、火腿、肉松、煎蛋 
 
 ### HeroDemo
 - 英雄学习技能案例：英雄李白，随着等级提升能够学习新的技能，包括Q,W,E。
 
 ### MonkeyDemo
 - 孙大圣变化案例：孙大圣本体是只猴子，他可以变成不同的动物：鱼、鸟。他的每一种变化都给他带来一种附加的本领。他变成鱼儿时，就可以到水里游泳；他变成鸟儿时，就可以在天上飞行。
    * 装饰者模式又名包装模式。装饰者模式以对客户端透明的方式扩展对象的功能，是继承的一个替代方案。
    * 装饰者模式的优点：
    * 1）目的在于扩展对象的功能。装饰者模式提供比继承更好的灵活性。装饰是动态的，运行时可以修改的；继承是静态的，编译期便已确定好。
    *  2）通过使用不同的装饰类及对它们的排列组合，可以创造出许多不同行为的组合。
    * 装饰者模式的缺点：1）会产生更多的对象。2）调试时不易排查错误。
    *
    * 装饰模式有透明和半透明两种，这两种的区别就在于装饰角色的接口与抽象构件角色的接口是否完全一致。
    *   1）透明的装饰模式也就是理想的装饰模式，要求具体构件角色、装饰角色的接口与抽象构件角色的接口完全一致。
    *   2）装饰角色的接口比抽象构件角色的接口宽的话，装饰角色实际上已经成了一个适配器角色，称为“半透明”的装饰模式。
    *
    *  装饰者模式：增强功能、不改变接口。
    *  半透明装饰者模式：增强功能、改变接口。
    *  适配器模式：不增加功能、改变接口。